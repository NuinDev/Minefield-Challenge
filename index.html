<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minefield Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        canvas {
            border-radius: 0.75rem;
            background-color: #2d3748;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
            display: block;
            max-width: 100%;
            height: auto;
            cursor: default;
        }

        .text-1 { color: #63b3ed; }
        .text-2 { color: #68d391; }
        .text-3 { color: #f6ad55; }
        .text-4 { color: #a78bfa; }
        .text-5 { color: #f06292; }
        .text-6 { color: #4fd1c5; }
        .text-7 { color: #e2e8f0; }
        .text-8 { color: #f7fafc; }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
            border: 2px solid #3182ce;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            margin-top: -8px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
            border: 2px solid #3182ce;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: #4a5568;
            border-radius: 2px;
        }

        input[type="range"]::-moz-range-track {
            height: 4px;
            background: #4a5568;
            border-radius: 2px;
        }
    </style>
</head>
<body class="selection:bg-blue-600 bg-gray-900">
    <div class="block md:hidden p-2 rounded-lg border border-gray-700 bg-gray-700 shadow-md fixed top-0 inset-x-0 mx-auto z-[51]" style="width: 338px; height: 68px;">
        <iframe data-aa='2398468' src='//ad.a-ads.com/2398468?size=320x50' style='width:320px; height:50px; border:0px; padding:0; overflow:hidden; background-color: transparent;'></iframe>
    </div>

    <div class="hidden md:block p-4 rounded-lg border border-gray-700 bg-gray-700 shadow-md fixed left-6 top-1/2 transform -translate-y-1/2 z-[51]" style="width: 154px; height: 634px;">
        <iframe data-aa='2398453' src='//ad.a-ads.com/2398453?size=120x600' style='width:120px; height:600px; border:0px; padding:0; overflow:hidden; background-color: transparent;'></iframe>
    </div>

    <div class="hidden md:block p-4 rounded-lg border border-gray-700 bg-gray-700 shadow-md fixed right-6 top-1/2 transform -translate-y-1/2 z-[51]" style="width: 154px; height: 634px;">
        <iframe data-aa='2398457' src='//ad.a-ads.com/2398457?size=120x600' style='width:120px; height:600px; border:0px; padding:0; overflow:hidden; background-color: transparent;'></iframe>
    </div>

    <div class="flex flex-col items-center p-6 bg-gray-800 rounded-xl shadow-2xl max-w-lg w-full relative">
        <h1 class="text-4xl font-extrabold text-gray-100 mb-6 tracking-tight">Minefield Challenge</h1>
        
        <div class="flex justify-between w-full mb-4 px-2">
            <div class="flex items-center text-gray-300 text-lg font-semibold">
                <span id="mine-count" class="mr-2">Mines: --</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                </svg>
            </div>
            <div class="flex items-center text-gray-300 text-lg font-semibold">
                <span id="timer" class="mr-2">Time: 00:00</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </div>
        </div>

        <canvas id="minefieldCanvas" class="border-4 border-blue-600"></canvas>

        <div id="game-message" class="mt-6 text-xl font-bold text-center text-gray-100"></div>

        <div class="flex justify-center space-x-4 mt-8 w-full">
            <button id="reset-button" class="px-6 py-3 bg-blue-700 text-white font-bold rounded-lg shadow-md hover:bg-blue-800 transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-opacity-75">
                New Game
            </button>
            <button id="info-button" class="px-6 py-3 bg-blue-700 text-white font-bold rounded-lg shadow-md hover:bg-blue-800 transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-opacity-75 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Info
            </button>
        </div>
    </div>

    <div id="modalBackdrop" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden z-[49]"></div>

    <div id="difficultyModal" class="fixed inset-0 flex items-center justify-center z-[50] p-4 hidden">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl max-w-sm w-full border border-blue-600">
            <h2 class="text-3xl font-bold text-gray-100 mb-6 text-center">Choose Difficulty</h2>

            <div class="space-y-4">
                <button id="easyDifficultyButton" class="difficulty-button w-full py-3 bg-blue-700 text-white font-semibold rounded-md hover:bg-blue-800 transition duration-300" data-difficulty="easy">Easy (10x10, 10 Mines)</button>
                <button id="mediumDifficultyButton" class="difficulty-button w-full py-3 bg-blue-700 text-white font-semibold rounded-md hover:bg-blue-800 transition duration-300" data-difficulty="medium">Medium (16x16, 40 Mines)</button>
                <button id="hardDifficultyButton" class="difficulty-button w-full py-3 bg-blue-700 text-white font-semibold rounded-md hover:bg-blue-800 transition duration-300" data-difficulty="hard">Hard (20x20, 80 Mines)</button>
            </div>

            <div id="customSettingsContainer" class="mt-4 space-y-4 rounded-lg p-2">
                <button id="customDifficultyButton" class="w-full py-3 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 transition duration-300">Custom</button>
                <div id="customSettings" class="space-y-4 pt-4 hidden">
                    <div>
                        <label for="gridSizeSlider" class="block text-gray-300 text-sm font-bold mb-2">Grid Size: <span id="gridSizeDisplay">16</span>x<span id="gridSizeDisplay2">16</span></label>
                        <input type="range" id="gridSizeSlider" min="5" max="50" value="16" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center text-gray-300 text-sm font-bold">
                        <span id="calculatedMinesDisplay">Mines: 40</span>
                    </div>
                    <p id="mineCountWarning" class="text-red-400 text-xs italic mt-1 hidden">Grid size must be between 5 and 50.</p>
                </div>
            </div>

            <button id="startGameButton" class="w-full mt-8 px-6 py-3 bg-green-700 text-white font-bold rounded-lg shadow-md hover:bg-green-800 transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-opacity-75">
                Start Game
            </button>
        </div>
    </div>

    <div id="instructionsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden z-[60] flex items-center justify-center p-4">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full border border-blue-600 text-gray-100 text-center">
            <h3 class="text-2xl font-bold mb-4">How to Play</h3>
            <div class="text-left">
                <h4 class="text-lg font-semibold mb-2">PC Controls:</h4>
                <ul class="list-disc list-inside mb-4">
                    <li><strong>Left Click:</strong> Reveal a cell.</li>
                    <li><strong>Right Click:</strong> Toggle Flag/Question Mark.</li>
                    <li><strong>Mouse Wheel:</strong> Zoom in/out.</li>
                    <li><strong>Drag (Left Click):</strong> Pan the board.</li>
                </ul>
                <h4 class="text-lg font-semibold mb-2">Mobile Controls:</h4>
                <ul class="list-disc list-inside mb-4">
                    <li><strong>Tap (single finger):</strong> Reveal a cell.</li>
                    <li><strong>Long Press (single finger):</strong> Toggle Flag/Question Mark.</li>
                    <li><strong>Pinch (two fingers):</strong> Zoom in/out.</li>
                    <li><strong>Drag (single finger):</strong> Pan the board.</li>
                </ul>
            </div>
            <button id="closeInstructionsButton" class="px-5 py-2 bg-blue-700 text-white font-semibold rounded-md hover:bg-blue-800 transition duration-300 mt-4">Got it!</button>
        </div>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('minefieldCanvas');
            const ctx = canvas.getContext('2d');
            const resetButton = document.getElementById('reset-button');
            const gameMessage = document.getElementById('game-message');
            const mineCountDisplay = document.getElementById('mine-count');
            const timerDisplay = document.getElementById('timer');
            const modalBackdrop = document.getElementById('modalBackdrop');
            const difficultyModal = document.getElementById('difficultyModal');
            const presetDifficultyButtons = document.querySelectorAll('.difficulty-button:not(#customDifficultyButton)'); 
            const customDifficultyButton = document.getElementById('customDifficultyButton');
            const customSettingsContainer = document.getElementById('customSettingsContainer');
            const customSettingsDiv = document.getElementById('customSettings');
            const gridSizeSlider = document.getElementById('gridSizeSlider'); 
            const gridSizeDisplay = document.getElementById('gridSizeDisplay');
            const gridSizeDisplay2 = document.getElementById('gridSizeDisplay2');
            const calculatedMinesDisplay = document.getElementById('calculatedMinesDisplay');
            const mineCountWarning = document.getElementById('mineCountWarning');
            const startGameButton = document.getElementById('startGameButton');
            const instructionsModal = document.getElementById('instructionsModal');
            const closeInstructionsButton = document.getElementById('closeInstructionsButton');
            const infoButton = document.getElementById('info-button');

            let currentGridSize = 16;
            let currentNumMines = 40;
            const BASE_CELL_SIZE = 60;
            const CUSTOM_MINE_DENSITY_RATIO = 80 / (20 * 20);

            let dynamicMinZoom = 0.5;
            let dynamicMaxZoom = 3.0;

            canvas.width = currentGridSize * BASE_CELL_SIZE;
            canvas.height = currentGridSize * BASE_CELL_SIZE;

            let cameraX = 0;
            let cameraY = 0;
            let zoomLevel = 1.0;
            
            let isDragging = false;
            let dragStartWorldX, dragStartWorldY;
            let initialClickX, initialClickY;
            const DRAG_THRESHOLD = 5;

            let touchStartX, touchStartY;
            let touchStartTime;
            let hasMoved = false;
            let isPinching = false;
            let initialPinchDistance = 0;
            let initialPinchCenter = { x: 0, y: 0 };
            const TAP_THRESHOLD_MS = 200;
            const TAP_MOVE_THRESHOLD = 10;
            const LONG_PRESS_THRESHOLD_MS = 500;
            let longPressTimeout = null;
            let touchStartCell = { row: -1, col: -1 };
            let isLongPressTriggered = false;

            let board = [];
            let revealedCount = 0;
            let gameActive = false;
            let minesFlagged = 0;
            let timerInterval;
            let secondsElapsed = 0;
            let isFirstClick = true;
            let hoveredCell = { row: -1, col: -1 };
            let isBoardReady = false;

            const CELL_COVERED = 0;
            const CELL_REVEALED = 1;
            const CELL_FLAGGED = 2;
            const CELL_MINE = 3;

            const COLORS = {
                covered: '#4a5568',
                revealed: '#2d3748',
                flag: '#e53e3e',
                mine: '#cbd5e1',
                clickedMine: '#f56565',
                hoverEffect: '#FFDD66',
                gridLine: '#9ca3af',
                text: {
                    1: '#63b3ed',
                    2: '#68d391',
                    3: '#f6ad55',
                    4: '#a78bfa',
                    5: '#f06292',
                    6: '#4fd1c5',
                    7: '#e2e8f0',
                    8: '#f7fafc'
                }
            };

            const countAdjacentMines = function(row, col) {
                let count = 0;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;

                        const newRow = row + dr;
                        const newCol = col + dc;

                        if (newRow >= 0 && newCol >= 0 &&
                            newRow < currentGridSize && newCol < currentGridSize &&
                            board[newRow][newCol].isMine) {
                            count++;
                        }
                    }
                }
                return count;
            };

            const drawMine = function(x, y, size, color, isDetonated = false) {
                const centerX = x + size / 2;
                const centerY = y + size / 2;

                if (isDetonated) {
                    const baseRadius = size * 0.3;
                    const pulseIntensity = 0.1;
                    const pulseSpeed = 0.01;

                    const pulseOffset = Math.sin(Date.now() * pulseSpeed) * pulseIntensity;
                    const currentRadius = baseRadius * (1 + pulseOffset);

                    ctx.beginPath();
                    ctx.arc(centerX, centerY, currentRadius * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 0, 0, ${0.4 * (1 - pulseOffset)})`;
                    ctx.fill();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.arc(centerX, centerY, currentRadius * 1.0, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 165, 0, ${0.6 * (1 - pulseOffset)})`;
                    ctx.fill();
                    ctx.closePath();
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();

                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI / 4) * i;
                    const innerX = centerX + Math.cos(angle) * (size / 4);
                    const innerY = centerY + Math.sin(angle) * (size / 4);
                    const outerX = centerX + Math.cos(angle) * (size / 2 - 5 / zoomLevel);
                    const outerY = centerY + Math.sin(angle) * (size / 2 - 5 / zoomLevel);
                    ctx.beginPath();
                    ctx.moveTo(innerX, innerY);
                    ctx.lineTo(outerX, outerY);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.stroke();
                    ctx.closePath();
                }
            };


            const drawFlag = function(x, y, size) {
                ctx.fillStyle = COLORS.flag;
                ctx.fillRect(x + size / 2 - 1 / zoomLevel, y + size / 4, 2 / zoomLevel, size / 2);
                ctx.beginPath();
                ctx.moveTo(x + size / 2 - 1 / zoomLevel, y + size / 4);
                ctx.lineTo(x + size / 2 + size / 4, y + size / 4 + size / 8);
                ctx.lineTo(x + size / 2 - 1 / zoomLevel, y + size / 4 + size / 4);
                ctx.closePath();
                ctx.fill();
            };

            const getEventWorldCoordinates = function(event) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (event.changedTouches && event.changedTouches.length > 0) {
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else if (event.touches && event.touches.length > 0) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }

                const canvasDisplayX = clientX - rect.left;
                const canvasDisplayY = clientY - rect.top;

                const canvasInternalX = canvasDisplayX * (canvas.width / rect.width);
                const canvasInternalY = canvasDisplayY * (canvas.height / rect.height);

                const worldX = (canvasInternalX / zoomLevel) + cameraX;
                const worldY = (canvasInternalY / zoomLevel) + cameraY;

                return { x: worldX, y: worldY };
            };

            const getDistance = (t1, t2) => {
                return Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2));
            };

            const getMidpointClient = (t1, t2) => {
                return {
                    x: (t1.clientX + t2.clientX) / 2,
                    y: (t1.clientY + t2.clientY) / 2
                };
            };


            const clampCamera = function() {
                const boardWorldWidth = currentGridSize * BASE_CELL_SIZE;
                const boardWorldHeight = currentGridSize * BASE_CELL_SIZE;

                const visibleWorldWidth = canvas.width / zoomLevel;
                const visibleWorldHeight = canvas.height / zoomLevel;

                const overdragBufferX = visibleWorldWidth * 0.5;
                const overdragBufferY = visibleWorldHeight * 0.5;

                let minCamX = -overdragBufferX;
                let maxCamX = (boardWorldWidth - visibleWorldWidth) + overdragBufferX;
                let minCamY = -overdragBufferY;
                let maxCamY = (boardWorldHeight - visibleWorldHeight) + overdragBufferY;

                if (boardWorldWidth < visibleWorldWidth) {
                    minCamX = (boardWorldWidth - visibleWorldWidth) / 2 - overdragBufferX;
                    maxCamX = (boardWorldWidth - visibleWorldWidth) / 2 + overdragBufferX;
                }
                if (boardWorldHeight < visibleWorldHeight) {
                    minCamY = (boardWorldHeight - visibleWorldHeight) / 2 - overdragBufferY;
                    maxCamY = (boardWorldHeight - visibleWorldHeight) / 2 + overdragBufferY;
                }
                
                cameraX = Math.max(minCamX, Math.min(cameraX, maxCamX));
                cameraY = Math.max(minCamY, Math.min(cameraY, maxCamY));
            };

            const startTimer = function() {
                timerInterval = setInterval(() => {
                    secondsElapsed++;
                    const minutes = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
                    const seconds = (secondsElapsed % 60).toString().padStart(2, '0');
                    timerDisplay.textContent = `Time: ${minutes}:${seconds}`;
                }, 1000);
            };

            const updateMineCountDisplay = function() {
                mineCountDisplay.textContent = `Mines: ${currentNumMines - minesFlagged}`;
            };

            const gameOver = function(won) {
                gameActive = false;
                clearInterval(timerInterval);

                if (won) {
                    gameMessage.textContent = 'You won! ðŸŽ‰';
                    gameMessage.classList.remove('text-red-400');
                    gameMessage.classList.add('text-green-400');
                    for (let r = 0; r < currentGridSize; r++) {
                        for (let c = 0; c < currentGridSize; c++) {
                            const cell = board[r][c];
                            if (cell.isMine && cell.state !== CELL_FLAGGED) {
                                cell.state = CELL_FLAGGED;
                            }
                            else if (!cell.isMine && cell.state !== CELL_REVEALED) {
                                cell.state = CELL_REVEALED;
                            }
                        }
                    }
                    minesFlagged = currentNumMines;
                } else {
                    gameMessage.textContent = 'Game Over! ðŸ’¥';
                    gameMessage.classList.remove('text-green-400');
                    gameMessage.classList.add('text-red-400');
                    
                    for (let r = 0; r < currentGridSize; r++) {
                        for (let c = 0; c < currentGridSize; c++) {
                            const cell = board[r][c];
                            if (cell.isMine) {
                                if (cell.state !== CELL_FLAGGED) {
                                    cell.state = CELL_REVEALED;
                                }
                            } else {
                                if (cell.state !== CELL_REVEALED) {
                                    cell.state = CELL_REVEALED;
                                }
                            }
                        }
                    }
                }
                updateMineCountDisplay();
                requestAnimationFrame(animationLoop);
            };

            const checkWin = function() {
                if (revealedCount === (currentGridSize * currentGridSize) - currentNumMines) {
                    gameOver(true);
                }
            };

            const uncoverCell = function(row, col, isInitialClick = false) {
                if (row < 0 || row >= currentGridSize || col < 0 || col >= currentGridSize ||
                    !isBoardReady || !board[row] || !board[row][col] ||
                    board[row][col].state === CELL_REVEALED || board[row][col].state === CELL_FLAGGED || !gameActive) {
                    return;
                }

                const cell = board[row][col];

                if (cell.isMine && !isInitialClick) {
                    cell.isClickedMine = true;
                    gameOver(false);
                    return;
                }

                cell.state = CELL_REVEALED;
                revealedCount++;

                if (cell.adjacentMines === 0) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            uncoverCell(row + dr, col + dc);
                        }
                    }
                }
                if (gameActive) {
                    drawBoard();
                }
                checkWin();
            };

            const toggleFlag = function(row, col) {
                if (!gameActive || !isBoardReady || !board[row] || !board[row][col] ||
                    board[row][col].state === CELL_REVEALED) {
                    return;
                }

                const cell = board[row][col];
                if (cell.state === CELL_COVERED) {
                    cell.state = CELL_FLAGGED;
                    minesFlagged++;
                } else if (cell.state === CELL_FLAGGED) {
                    cell.state = CELL_COVERED;
                    minesFlagged--;
                }
                updateMineCountDisplay();
                drawBoard();
                checkWin();
            };

            const placeMines = function(firstClickRow, firstClickCol) {
                let minesPlaced = 0;
                const safeCells = new Set();

                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const r = firstClickRow + dr;
                        const c = firstClickCol + dc;
                        if (r >= 0 && r < currentGridSize && c >= 0 && c < currentGridSize) {
                            safeCells.add(`${r},${c}`);
                        }
                    }
                }

                while (minesPlaced < currentNumMines) {
                    const r = Math.floor(Math.random() * currentGridSize);
                    const c = Math.floor(Math.random() * currentGridSize);
                    const cellCoords = `${r},${c}`;

                    if (!board[r][c].isMine && !safeCells.has(cellCoords)) {
                        board[r][c].isMine = true;
                        minesPlaced++;
                    }
                }

                for (let r = 0; r < currentGridSize; r++) {
                    for (let c = 0; c < currentGridSize; c++) {
                        if (!board[r][c].isMine) {
                            board[r][c].adjacentMines = countAdjacentMines(r, c);
                        }
                    }
                }
            };

            const drawBoard = function() {
                if (!isBoardReady) {
                    return;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(-cameraX * zoomLevel, -cameraY * zoomLevel);
                ctx.scale(zoomLevel, zoomLevel);

                const scaledCellSize = BASE_CELL_SIZE;

                for (let r = 0; r < currentGridSize; r++) {
                    for (let c = 0; c < currentGridSize; c++) {
                        if (!board[r] || !board[r][c]) { 
                            continue; 
                        }
                        const cell = board[r][c];
                        const x = c * scaledCellSize;
                        const y = r * scaledCellSize;

                        ctx.beginPath();
                        ctx.rect(x, y, scaledCellSize, scaledCellSize);
                        if (cell.state === CELL_REVEALED) {
                            ctx.fillStyle = COLORS.revealed;
                        } else {
                            ctx.fillStyle = COLORS.covered;
                        }
                        ctx.fill();
                        ctx.closePath();

                        if (cell.state === CELL_REVEALED) {
                            if (!cell.isMine && cell.adjacentMines > 0) {
                                ctx.fillStyle = COLORS.text[cell.adjacentMines] || COLORS.text[8];
                                ctx.font = `bold ${scaledCellSize * 0.6}px "Inter", sans-serif`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(cell.adjacentMines, x + scaledCellSize / 2, y + scaledCellSize / 2);
                            } else if (cell.isMine) {
                                const mineColor = cell.isClickedMine ? COLORS.clickedMine : COLORS.mine;
                                drawMine(x, y, scaledCellSize, mineColor, cell.isClickedMine);
                            }
                        }

                        if (gameActive && (cell.state === CELL_COVERED || cell.state === CELL_FLAGGED) && r === hoveredCell.row && c === hoveredCell.col) {
                            ctx.beginPath();
                            ctx.rect(x, y, scaledCellSize, scaledCellSize);
                            ctx.fillStyle = COLORS.hoverEffect;
                            ctx.fill();
                            ctx.closePath();
                        }

                        if (cell.state === CELL_FLAGGED) {
                            drawFlag(x, y, scaledCellSize);
                        }
                    }
                }
                ctx.restore();

                ctx.strokeStyle = COLORS.gridLine;

                const getDesiredScreenLineWidth = function(gridSize) {
                    if (gridSize <= 15) {
                        return 4; 
                    } else if (gridSize <= 30) {
                        return 3; 
                    } else {
                        return 2; 
                    }
                };

                const desiredScreenLineWidth = getDesiredScreenLineWidth(currentGridSize);

                const internalCanvasWidth = canvas.width;
                const displayedCanvasWidth = canvas.clientWidth || internalCanvasWidth;
                const cssScaleFactor = internalCanvasWidth / displayedCanvasWidth;

                ctx.lineWidth = desiredScreenLineWidth * cssScaleFactor;


                const worldGridWidth = currentGridSize * BASE_CELL_SIZE;
                const worldGridHeight = currentGridSize * BASE_CELL_SIZE;

                const displayGridLeft = Math.round((0 - cameraX) * zoomLevel);
                const displayGridTop = Math.round((0 - cameraY) * zoomLevel);
                const displayGridRight = Math.round((worldGridWidth - cameraX) * zoomLevel);
                const displayGridBottom = Math.round((worldGridHeight - cameraY) * zoomLevel);

                ctx.save();
                ctx.beginPath();
                ctx.rect(displayGridLeft, displayGridTop,
                         displayGridRight - displayGridLeft,
                         displayGridBottom - displayGridTop);
                ctx.clip();

                for (let r = 0; r <= currentGridSize; r++) {
                    const worldY = r * BASE_CELL_SIZE;
                    const displayY = Math.round((worldY - cameraY) * zoomLevel); 
                    
                    ctx.beginPath();
                    ctx.moveTo(displayGridLeft, displayY);
                    ctx.lineTo(displayGridRight, displayY);
                    ctx.stroke();
                }

                for (let c = 0; c <= currentGridSize; c++) {
                    const worldX = c * BASE_CELL_SIZE;
                    const displayX = Math.round((worldX - cameraX) * zoomLevel); 
                    
                    ctx.beginPath();
                    ctx.moveTo(displayX, displayGridTop);
                    ctx.lineTo(displayX, displayGridBottom);
                    ctx.stroke();
                }

                ctx.restore();
            };

            const animationLoop = function() {
                drawBoard();

                let shouldContinueAnimation = false;
                if (gameActive) {
                    shouldContinueAnimation = true;
                } else if (isBoardReady) {
                    for (let r = 0; r < currentGridSize; r++) {
                        for (let c = 0; c < currentGridSize; c++) {
                            if (board[r] && board[r][c] && board[r][c].isClickedMine) {
                                shouldContinueAnimation = true;
                                break;
                            }
                        }
                        if (shouldContinueAnimation) break;
                    }
                }
                
                if (shouldContinueAnimation) {
                    requestAnimationFrame(animationLoop);
                }
            };


            const resizeCanvas = function() {
                canvas.width = currentGridSize * BASE_CELL_SIZE;
                canvas.height = currentGridSize * BASE_CELL_SIZE;
                
                calculateDynamicZoomLimits(); 
                zoomLevel = Math.max(dynamicMinZoom, Math.min(zoomLevel, dynamicMaxZoom));
                
                cameraX = (currentGridSize * BASE_CELL_SIZE - canvas.width / zoomLevel) / 2;
                cameraY = (currentGridSize * BASE_CELL_SIZE - canvas.height / zoomLevel) / 2;

                clampCamera();
                drawBoard();
            };

            const calculateDynamicZoomLimits = function() {
                const boardWorldWidth = currentGridSize * BASE_CELL_SIZE;
                const boardWorldHeight = currentGridSize * BASE_CELL_SIZE;

                const canvasDisplayWidth = canvas.clientWidth;
                const canvasDisplayHeight = canvas.clientHeight;

                const zoomToFitWidth = canvasDisplayWidth / boardWorldWidth;
                const zoomToFitHeight = canvasDisplayHeight / boardWorldHeight;
                
                dynamicMinZoom = Math.min(zoomToFitWidth, zoomToFitHeight) * 0.9;
                
                dynamicMinZoom = Math.max(0.1, dynamicMinZoom);
                
                dynamicMaxZoom = 250 / BASE_CELL_SIZE;
                dynamicMaxZoom = Math.min(5.0, dynamicMaxZoom);
            };


            const initializeGame = function(gridSize = currentGridSize, numMines = currentNumMines) {
                isBoardReady = false;
                currentGridSize = gridSize;
                currentNumMines = numMines;

                canvas.width = currentGridSize * BASE_CELL_SIZE;
                canvas.height = currentGridSize * BASE_CELL_SIZE;
                
                calculateDynamicZoomLimits(); 
                zoomLevel = Math.max(1.0, dynamicMinZoom);

                cameraX = (currentGridSize * BASE_CELL_SIZE - canvas.width / zoomLevel) / 2;
                cameraY = (currentGridSize * BASE_CELL_SIZE - canvas.height / zoomLevel) / 2;
                
                clampCamera();

                board = [];
                for (let r = 0; r < currentGridSize; r++) {
                    board[r] = [];
                    for (let c = 0; c < currentGridSize; c++) {
                        board[r][c] = {
                            isMine: false,
                            state: CELL_COVERED,
                            adjacentMines: 0,
                            isClickedMine: false,
                        };
                    }
                }
                
                isBoardReady = true;

                revealedCount = 0;
                gameActive = true;
                minesFlagged = 0;
                secondsElapsed = 0;
                isFirstClick = true;
                hoveredCell = { row: -1, col: -1 };
                
                gameMessage.textContent = '';
                gameMessage.classList.remove('text-green-400', 'text-red-400');
                clearInterval(timerInterval);

                updateMineCountDisplay();
                startTimer();
                requestAnimationFrame(animationLoop);
            };

            canvas.addEventListener('mousedown', function(event) {
                if (event.button === 0) {
                    const worldCoords = getEventWorldCoordinates(event);
                    dragStartWorldX = worldCoords.x;
                    dragStartWorldY = worldCoords.y;

                    initialClickX = event.clientX;
                    initialClickY = event.clientY;
                    isDragging = true;
                } else if (event.button === 2) {
                    if (gameActive) {
                        const worldCoords = getEventWorldCoordinates(event);
                        const col = Math.floor(worldCoords.x / BASE_CELL_SIZE);
                        const row = Math.floor(worldCoords.y / BASE_CELL_SIZE);
                        if (row >= 0 && row < currentGridSize && col >= 0 && col < currentGridSize) {
                            toggleFlag(row, col);
                        }
                    }
                }
            });

            canvas.addEventListener('mouseup', function(event) {
                if (!gameActive) {
                    isDragging = false;
                    return;
                }
                
                if (event.button === 0) {
                    const distMovedX = Math.abs(event.clientX - initialClickX);
                    const distMovedY = Math.abs(event.clientY - initialClickY);

                    if (distMovedX < DRAG_THRESHOLD && distMovedY < DRAG_THRESHOLD) {
                        const worldCoords = getEventWorldCoordinates(event);
                        const col = Math.floor(worldCoords.x / BASE_CELL_SIZE);
                        const row = Math.floor(worldCoords.y / BASE_CELL_SIZE);

                        if (row >= 0 && row < currentGridSize && col >= 0 && col < currentGridSize) {
                            if (isFirstClick) {
                                placeMines(row, col);
                                uncoverCell(row, col, true);
                                isFirstClick = false; 
                            } else {
                                uncoverCell(row, col);
                            }
                        }
                    }
                    isDragging = false;
                }
            });

            canvas.addEventListener('contextmenu', function(event) {
                event.preventDefault();
            });

            canvas.addEventListener('mousemove', function(event) {
                if (gameActive && event.buttons === 0) {
                    const worldCoords = getEventWorldCoordinates(event);
                    const col = Math.floor(worldCoords.x / BASE_CELL_SIZE);
                    const row = Math.floor(worldCoords.y / BASE_CELL_SIZE);

                    if (row !== hoveredCell.row || col !== hoveredCell.col) {
                        hoveredCell = { row: row, col: col };
                        drawBoard(); 
                    }
                }

                if (isDragging && event.buttons === 1) {
                    const rect = canvas.getBoundingClientRect();
                    const canvasDisplayX = event.clientX - rect.left;
                    const canvasDisplayY = event.clientY - rect.top; 
                    
                    const canvasInternalX = canvasDisplayX * (canvas.width / rect.width);
                    const canvasInternalY = canvasDisplayY * (canvas.height / rect.height);
                    
                    cameraX = dragStartWorldX - (canvasInternalX / zoomLevel);
                    cameraY = dragStartWorldY - (canvasInternalY / zoomLevel); 
                    
                    clampCamera();
                    drawBoard();
                }
            });

            canvas.addEventListener('mouseleave', function(event) {
                isDragging = false;
                if (hoveredCell.row !== -1 || hoveredCell.col !== -1) {
                    hoveredCell = { row: -1, col: -1 };
                    if (gameActive) { 
                        drawBoard(); 
                    }
                }
            });

            canvas.addEventListener('wheel', function(event) {
                event.preventDefault();

                const scaleFactor = 1.1;
                const mouseWorld = getEventWorldCoordinates(event);

                const oldZoomLevel = zoomLevel;

                if (event.deltaY < 0) {
                    zoomLevel *= scaleFactor;
                } else {
                    zoomLevel /= scaleFactor;
                }

                zoomLevel = Math.max(dynamicMinZoom, Math.min(zoomLevel, dynamicMaxZoom));

                cameraX += (mouseWorld.x - cameraX) * (1 - oldZoomLevel / zoomLevel);
                cameraY += (mouseWorld.y - cameraY) * (1 - oldZoomLevel / zoomLevel);

                clampCamera();
                drawBoard();
            });

            canvas.addEventListener('touchstart', function(event) {
                event.preventDefault();

                if (longPressTimeout) {
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;
                }
                isLongPressTriggered = false;

                if (event.touches.length === 1) {
                    isDragging = true;
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                    touchStartTime = Date.now();
                    hasMoved = false;
                    
                    const worldCoords = getEventWorldCoordinates(event);
                    dragStartWorldX = worldCoords.x;
                    dragStartWorldY = worldCoords.y;

                    const col = Math.floor(worldCoords.x / BASE_CELL_SIZE);
                    const row = Math.floor(worldCoords.y / BASE_CELL_SIZE);
                    touchStartCell = { row: row, col: col };
                    
                    if (gameActive) {
                        longPressTimeout = setTimeout(() => {
                            if (!hasMoved && !isPinching && gameActive && touchStartCell.row !== -1 && touchStartCell.col !== -1) {
                                toggleFlag(touchStartCell.row, touchStartCell.col);
                                isLongPressTriggered = true;
                            }
                            longPressTimeout = null;
                        }, LONG_PRESS_THRESHOLD_MS);
                    }

                } else if (event.touches.length === 2) {
                    isPinching = true;
                    isDragging = false;
                    hasMoved = true;
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;
                    
                    initialPinchDistance = getDistance(event.touches[0], event.touches[1]);
                    const midpointClient = getMidpointClient(event.touches[0], event.touches[1]);
                    initialPinchCenter = getEventWorldCoordinates({ clientX: midpointClient.x, clientY: midpointClient.y });
                }
            });

            canvas.addEventListener('touchmove', function(event) {
                event.preventDefault();

                if (event.touches.length === 1 && isDragging) {
                    const currentClientX = event.touches[0].clientX;
                    const currentClientY = event.touches[0].clientY;

                    if (Math.abs(currentClientX - touchStartX) > TAP_MOVE_THRESHOLD ||
                        Math.abs(currentClientY - touchStartY) > TAP_MOVE_THRESHOLD) {
                        hasMoved = true;
                        if (longPressTimeout) {
                            clearTimeout(longPressTimeout);
                            longPressTimeout = null;
                        }
                    }

                    const rect = canvas.getBoundingClientRect();
                    const canvasDisplayX = currentClientX - rect.left;
                    const canvasDisplayY = currentClientY - rect.top;

                    const canvasInternalX = canvasDisplayX * (canvas.width / rect.width);
                    const canvasInternalY = canvasDisplayY * (canvas.height / rect.height);
                    
                    cameraX = dragStartWorldX - (canvasInternalX / zoomLevel);
                    cameraY = dragStartWorldY - (canvasInternalY / zoomLevel); 
                    
                    clampCamera();
                    drawBoard();
                } else if (event.touches.length === 2 && isPinching) {
                    hasMoved = true;
                    
                    const currentPinchDistance = getDistance(event.touches[0], event.touches[1]);
                    const newZoomLevel = Math.max(dynamicMinZoom, Math.min(dynamicMaxZoom, zoomLevel * (currentPinchDistance / initialPinchDistance)));

                    const oldZoom = zoomLevel;
                    zoomLevel = newZoomLevel;

                    cameraX += (initialPinchCenter.x - cameraX) * (1 - oldZoom / newZoomLevel);
                    cameraY += (initialPinchCenter.y - cameraY) * (1 - oldZoom / newZoomLevel);

                    clampCamera();
                    drawBoard();
                    initialPinchDistance = currentPinchDistance;
                }
            });

            canvas.addEventListener('touchend', function(event) {
                event.preventDefault();

                if (longPressTimeout) {
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;
                }

                if (event.touches.length === 0) {
                    if (!hasMoved && !isLongPressTriggered && !isPinching && gameActive) { 
                        const worldCoords = getEventWorldCoordinates(event); 
                        const col = Math.floor(worldCoords.x / BASE_CELL_SIZE);
                        const row = Math.floor(worldCoords.y / BASE_CELL_SIZE);

                        if (row === touchStartCell.row && col === touchStartCell.col &&
                            row >= 0 && row < currentGridSize && col >= 0 && col < currentGridSize) {
                            
                            const timeElapsed = Date.now() - touchStartTime;
                            if (timeElapsed < TAP_THRESHOLD_MS) {
                                if (isFirstClick) {
                                    placeMines(row, col);
                                    uncoverCell(row, col, true);
                                    isFirstClick = false;
                                } else {
                                    uncoverCell(row, col);
                                }
                            }
                        }
                    }
                    isDragging = false;
                    isPinching = false;
                    hasMoved = false;
                    isLongPressTriggered = false; 
                    hoveredCell = { row: -1, col: -1 };
                    drawBoard();
                }
            });

            let isCustomModeActive = false;

            resetButton.addEventListener('click', function() {
                modalBackdrop.classList.remove('hidden');
                difficultyModal.classList.remove('hidden');
                highlightActiveDifficultyButton();
            });
            window.addEventListener('resize', resizeCanvas);

            const highlightActiveDifficultyButton = function() {
                presetDifficultyButtons.forEach(btn => btn.classList.remove('border-2', 'border-yellow-400', 'shadow-lg'));
                customSettingsContainer.classList.remove('border-2', 'border-yellow-400', 'shadow-lg');
                customSettingsDiv.classList.add('hidden');

                if (isCustomModeActive) {
                    customSettingsDiv.classList.remove('hidden');
                    customSettingsContainer.classList.add('border-2', 'border-yellow-400', 'shadow-lg');
                } else {
                    let selectedId = null;
                    if (currentGridSize === 10 && currentNumMines === 10) {
                        selectedId = 'easyDifficultyButton';
                    } else if (currentGridSize === 16 && currentNumMines === 40) {
                        selectedId = 'mediumDifficultyButton';
                    } else if (currentGridSize === 20 && currentNumMines === 80) {
                        selectedId = 'hardDifficultyButton';
                    }

                    if (selectedId) {
                        document.getElementById(selectedId).classList.add('border-2', 'border-yellow-400', 'shadow-lg');
                    } else {
                        isCustomModeActive = true;
                        customSettingsDiv.classList.remove('hidden');
                        customSettingsContainer.classList.add('border-2', 'border-yellow-400', 'shadow-lg');
                    }
                }
            };

            presetDifficultyButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const difficulty = this.dataset.difficulty;
                    
                    if (difficulty === 'easy') {
                        currentGridSize = 10;
                        currentNumMines = 10;
                    } else if (difficulty === 'medium') {
                        currentGridSize = 16;
                        currentNumMines = 40;
                    } else if (difficulty === 'hard') {
                        currentGridSize = 20;
                        currentNumMines = 80;
                    }
                    gridSizeSlider.value = currentGridSize;
                    updateCustomDisplays(currentGridSize);
                    mineCountWarning.classList.add('hidden');
                    isCustomModeActive = false;
                    highlightActiveDifficultyButton(); 
                    validateCustomGameSettings();
                });
            });

            customDifficultyButton.addEventListener('click', function() {
                isCustomModeActive = true;
                highlightActiveDifficultyButton(); 

                currentGridSize = parseInt(gridSizeSlider.value);
                currentNumMines = Math.max(1, Math.floor(currentGridSize * currentGridSize * CUSTOM_MINE_DENSITY_RATIO));
                
                updateCustomDisplays(currentGridSize);
                validateCustomGameSettings();
            });

            gridSizeSlider.addEventListener('input', function() {
                isCustomModeActive = true; 

                let newSize = parseInt(this.value);
                currentGridSize = newSize;
                
                let calculatedMines = Math.floor(currentGridSize * currentGridSize * CUSTOM_MINE_DENSITY_RATIO);
                const totalCells = currentGridSize * currentGridSize;
                const maxAllowedMines = totalCells - 9;
                
                currentNumMines = Math.max(1, Math.min(calculatedMines, maxAllowedMines));

                updateCustomDisplays(currentGridSize);
                highlightActiveDifficultyButton(); 
                validateCustomGameSettings();
            });


            const updateCustomDisplays = function(size) {
                gridSizeDisplay.textContent = size;
                gridSizeDisplay2.textContent = size;
                calculatedMinesDisplay.textContent = `Mines: ${currentNumMines}`;
            };


            const validateCustomGameSettings = function() {
                const totalCells = currentGridSize * currentGridSize;
                const maxAllowedMines = totalCells - 9;
                
                let isValid = true;
                let warningMessage = '';

                if (isNaN(currentGridSize) || currentGridSize < 5 || currentGridSize > 50) { 
                    isValid = false;
                    warningMessage = 'Grid size must be between 5 and 50.';
                } else if (currentNumMines < 1 || currentNumMines >= maxAllowedMines) {
                    isValid = false;
                    warningMessage = `Mine count (${currentNumMines}) is invalid for a ${currentGridSize}x${currentGridSize} grid. Must be at least 1 and less than ${maxAllowedMines}.`;
                }

                if (!isValid) {
                    mineCountWarning.textContent = warningMessage;
                    mineCountWarning.classList.remove('hidden');
                    startGameButton.disabled = true;
                    startGameButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    mineCountWarning.classList.add('hidden');
                    startGameButton.disabled = false;
                    startGameButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            };


            startGameButton.addEventListener('click', function() {
                currentGridSize = Math.max(5, Math.min(currentGridSize, 50));
                const maxAllowedMinesAtStart = (currentGridSize * currentGridSize) - 9;
                currentNumMines = Math.max(1, Math.min(currentNumMines, maxAllowedMinesAtStart));
                
                modalBackdrop.classList.add('hidden');
                difficultyModal.classList.add('hidden');
                initializeGame(currentGridSize, currentNumMines);
            });

            infoButton.addEventListener('click', () => {
                instructionsModal.classList.remove('hidden');
            });

            closeInstructionsButton.addEventListener('click', () => {
                instructionsModal.classList.add('hidden');
            });

            modalBackdrop.classList.remove('hidden');
            difficultyModal.classList.remove('hidden');
            highlightActiveDifficultyButton();
            updateCustomDisplays(currentGridSize);
            validateCustomGameSettings(); 
        };
    </script>
</body>
